---
title: "OSRM Travel-time calculation with R and data visualization with Observable"
subtitle: "Application to artifical climbing walls in Paris and its neighbourhood"
author: Ronan Ysebaert
date: "June 2022"
format:
  html:
    theme: sandstone
---

The aim of this document consists in showing how to build, visualize and reproduce accessibility indicators by combining points of interest (POI) coming from the OpenStreetMap database, socio-economic indicators included in small territorial division (IRIS) and routing engines (OSRM).

The graphical outputs displayed in this notebook are also available in an [Observable collection](https://observablehq.com/collection/@rysebaert/climbing_paris "Go to Observable Notebook").

It is applied to sport climbing in Paris, but this example could be easily extended to other areas of interest or other amenities (OpenStreetMap key-values).

To introduce the reader to the issues raised by indoor sport-climbing in Paris, have a look to [this notebook](https://observablehq.com/d/d2be39c4dd55a32d?collection=@rysebaert/climbing_paris "Go to Observable Notebook").

This Quarto document combines 2 computer languages : R for data processing, and D3.js for data visualizations.

# Data processing with R

## Data sources

Three data providers are used to build the consolidated data of this document.

-   **IGN** : [The Contour...IRIS® édition 2020](https://geoservices.ign.fr/contoursiris "Access to input geometries (France)"), which corresponds to the lowest territorial division in France (below the commune level).

-   **INSEE** : IRIS [Median income](https://www.insee.fr/fr/statistiques/6049648 "Go to input data") and [population](https://www.insee.fr/fr/statistiques/5650720?sommaire=4658626 "Go to input data") in 2019.

-   **OpenStreetMap** : download of Point Of Interest (POI) and travel time calculation by bike between IRIS centroids and POI, using the [OSRM routing engine](http://project-osrm.org/ "Access to OSRM Website").

Input data is not provided in the Github repository (too large files), but can be easily be downloaded.

## Map layout preparation

A bounding box of 5 km around Paris, without Bois de Boulogne et Bois de Vincennes for a better centering of the map layout.

A second bouding box (10 km around Paris) is created to catch OpenStreetMap POI in the neighbourhood of this study area.

```{r, eval = FALSE}
# 1. Map layout preparation at IRIS scale (source IGN)----
library(sf)
iris <- st_read("data-raw/CONTOURS-IRIS.shp", quiet = TRUE)

# Extract Paris and delete 
# Bois-de-Vincennes / Boulogne Iris for map template
iris$dep <- substr(iris$INSEE_COM, 1, 2)
paris <- iris[iris$dep == "75",]
paris <- paris[!paris$NOM_IRIS %in% c("Bois de Vincennes 1",
                                      "Bois de Vincennes 2",
                                      "Bois de Boulogne 1",
                                      "Bois de Boulogne 2",
                                      "Bois de Boulogne 3"),]
paris <- st_union(paris)

# 5 km around Paris map layout
paris5k <- st_buffer(paris, 5000)
paris5k <- st_as_sfc(st_bbox(paris5k, crs = 2154))

# 10 km around Paris (get OSM data) in long/lat
paris10k <- st_buffer(paris, 10000)
paris10k <- st_as_sfc(st_bbox(paris10k, crs = 2154))

# Intersection with IRIS
iris10k <- st_intersection(iris, paris10k)

# Bounding box for osm extraxt
paris10k <- st_transform(paris10k, 4326)
paris10k <- st_bbox(paris10k) 
paris10k <- as.vector(paris10k)
```

## Feed IRIS layer by socio-economic data (INSEE)

Data is enriched by socio-economic data (disposible income) for further analysis. We keep only "Habitation" IRIS for origins-destination calculation.

```{r, eval = FALSE}
library(readxl)
df <- read_xlsx("data-raw/base-ic-evol-struct-pop-2018.xlsx", skip = 5, sheet = "IRIS")
iris10k <- merge(iris10k[,c("CODE_IRIS", "NOM_IRIS", "TYP_IRIS", "NOM_COM")], 
              df[,c("IRIS","P18_POP")],
              by.x = "CODE_IRIS", by.y = "IRIS", all.x = TRUE)

df <- read_xlsx("data-raw/BASE_TD_FILO_DISP_IRIS_2019.xlsx", skip = 5, sheet = "IRIS_DISP")
iris10k <- merge(iris10k, df[,c("IRIS","DISP_MED19")],
              by.x = "CODE_IRIS", by.y = "IRIS", all.x = TRUE)

iris <- st_intersection(iris, paris5k)
```

## Prepare IRIS for travel-time calculation

IRIS centroids are extracted. These points will be used for the origins of travel-time calculations. Only IRIS including dwellings are kept (TYP_IRIS == "H").

These `sf` objects are transformed in latitude/longitude (origin-destination calculations requirements and for final export in geojson format).

```{r, eval = FALSE}
# Keep only habitation IRIS for origins calculation
ori <- iris10k[iris10k$TYP_IRIS == "H",]
ori <- st_centroid(ori)

ori <- st_transform(ori, crs = 4326)
iris <- st_transform(iris, crs = 4326)
com <- st_transform(com, crs = 4326)
```

## Import OSM data with R

Indoor sport climbing points of interest are downloaded from OpenStreetMap thanks to the `osmdata` R package (Padgham, 2022).

To access to these OSM features, the OSM key-value pair must be set. For climbing areas, it corresponds to the sport = climbing OSM tag. In the [OpenStreetMap wiki](https://wiki.openstreetmap.org/wiki/Tag:sport%3Dclimbing "Tag:sport=climbing in OSM wiki"), it is mentioned that "*sport=climbing should be preferably applied to noded for artificial climbing walls".* Thus, we only consider points responding to the query.

The geographical coverage of the query covers a bounding box of 10 km around Paris (`paris10k`\`). At the end, only useful OSM attributes are kept. Associative and private structures are differentiated for thematic purpose.

I argue that the accuracy and completeness of the data is quite good : I have edited missing points on OpenStreetMap with my personal knowledge and upstream investigation :-)

```{r, eval = FALSE}
# 3. Extract sport climbing areas from OSM ----
library(osmdata)

# define a bounding box
q0 <- opq(bbox = paris10k) 

# extract climbing areas
q <- add_osm_feature(opq = q0, key = 'sport', value = "climbing")
res <- osmdata_sf(q)
dest <- res$osm_points

# Manage private and associative areas
private <- dest[!is.na(dest$brand),]
asso <- dest[!is.na(dest$federation),]
asso$type <- "Associative structure"
private$type <- "Speculative structure"
dest <- rbind(asso, private)
dest <- dest[,cols]
dest$federation[is.na(dest$federation)] <- "Private"


# Manage artificial area type
dest[c("climbing.toprope", "climbing.boulder")][is.na(dest[c("climbing.toprope", "climbing.boulder")])] <- "no"

dest$climbing_type <- ifelse(dest$climbing.toprope == 'yes'  & 
                               dest$climbing.boulder == "yes",'Wall and bouldering',
                             ifelse(dest$climbing.toprope == 'yes' & 
                                      dest$climbing.boulder == "no" , 'Wall',
                                    ifelse(dest$climbing.toprope == 'no' &
                                             dest$climbing.boulder == "yes" , 'Bouldering',
                                           NA)))

cols <- c("osm_id", "name", "climbing_type", "climbing.length",
          "climbing.routes", "type", "federation", "brand", "SUM_POP18", "MIN_REV19", "MOY_REV19", "MAX_REV19")

dest <- dest[,cols]

# Intersection with bouding box 
poi <- st_transform(dest, 2154)
poi <- st_intersection(poi, paris5k)
poi <- st_transform(poi, 4326)
```

## Input layers visualisation

The data preparation allows to prepare origins-destinations layers for travel-time calculation. Origins correspond to the IRIS layer (only type H : 2141 points). Destinations to artificial climbing areas (45 points).

```{r, eval = TRUE, echo = FALSE, cache.comments=TRUE}
library(sf)
poi <- st_read("data-conso/poi.geojson", quiet = TRUE)
iris <- st_read("data-conso/iris.geojson", quiet = TRUE)
com <- st_read("data-conso/com.geojson", quiet = TRUE)

poi <- st_transform(poi, 2154)
iris <- st_transform(iris, 2154)
com <- st_transform(com, 2154)
```

```{r, eval = TRUE, out.width= "100%", warning=FALSE}
library(mapsf)
ori <- st_centroid(iris)
ori <- ori[ori$TYP_IRIS == "H",]

par(mar = c(0,0,0,0))

my_theme <- list(bg = NA, fg = NA, mar = c(0, 0, 0, 0), tab = TRUE, pos = "left", 
                  inner = TRUE, line = 1.3, cex = 1, font = 2)

mf_init(com, expandBB = c(0,0.4,0,0), theme = my_theme)

mf_typo(
  x = iris, var = "TYP_IRIS", 
  pal = c("peachpuff", "#feb8ff", "#f0e6f0", "#f1f7ab"), lwd = 0.25,
  val_order = c("H", "A", "D", "Z"), border = "white", leg_pos = c(631000, 6872000),
  leg_title = "IRIS types (H = dwellings)", add = TRUE)

mf_map(ori, pch = 20, col = "red", cex = .2, add = TRUE)

mf_legend(
  type = "symb", pos =  c(631000, 6864000), val = c("H", "H"),
  pt_pch = c(20,20), pt_cex =.2, title = "Origins : IRIS centroids type H",
  pal = c("red", "red"))

mf_typo(x = poi, var = "federation", pch = 21, cex = .7,
        val_order = c("Private", "FSGT", "FFME"),
        pal = c("#377eb8", "#e41a1c", "#ff7f00"),
        leg_title = "Destinations:\nArtificial climbing areas",
        leg_pos = c(631000, 6860000),
        add = TRUE)

mf_map(com, col = NA, border = "black", add = TRUE)

mf_title("Layers presentation for origins-destinations calculation")
mf_scale(size = 5, col = "black", pos = "bottomright")
mf_credits(paste0("Sources : © OpenStreetMap and Contributors, IGN, INSEE, 2022\n",
                  "Realisation : Ronan Ysebaert, 2022"))
```

## Time distance to climbing artificial structures

We have now required origins and destinations required to compute travel-time calculations. The computation is realized using the `osrm` R package (Giraud, 2022). This package allows to compute routes, trips, isochrones and travel distances matrices (travel time and kilometric distance).

Considering that the input data are quite important (more than 2000 origin points and 48 destination points) and to avoid to overload the OSRM demo server, I have run my own instance of OSRM based on docker container. To do so the procedure is explained in the [following documentation](https://github.com/Project-OSRM/osrm-backend#using-docker "Run OSRM with docker"), or more specifically for Windows [here](https://gist.github.com/AlexandraKapp/e0eee2beacc93e765113aff43ec77789 "How to set up your own OSRM backend with Docker on Windows").

Once it is done, the connection to the rounting engine is operational with the url `http://localhost:5000/`\`.

With OSRM, it is possible to choose several profiles depending on what kind of routing we want to use (car, bike, walking). In our case, we choose by bike considering the fact this is a widespread practice for climbers to reach climbing areas with this transport mean. Moreover, it allows also to avoid to use the car profile, which underestimates the travel-time in metropolitan areas (trafic congestion not taken into account).

The bicycle profile is described in the [github OSRM repository](https://github.com/Project-OSRM/osrm-backend/blob/master/profiles/bicycle.lua "OSRM bicycle profile"). Basically, the default speed is 15 km/h. It avoids the access to highways, reduce the driving speed by 30 % for unsafe roads. It is important to keep in mind that landforms (elevation) are not considered in the default profile. Some thoughts and solutions exist on the subject, using elevation rasters ([Liedman, 2022](https://www.liedman.net/2015/04/13/add-elevation-data-to-osrm/ "Adding elevation data to OSRM") ; [Mapbox, 2015](https://blog.mapbox.com/elevation-aware-routing-profiles-in-mapbox-directions-21e182a85165 "Elevation-aware routing profiles in Mapbox Directions")).

The code below compute travel-time calculation between the geometric center of IRIS (`ori`) and artificial climbing areas (`poi`). It is done for all climbing structures and reproduced according to the type of climbing structure : private or associative structures. For associative structures, we distinguish the FSGT and FFME federations, who do not exactly the same goals in term of practice.

```{r, eval = FALSE}
library(osrm)

# Manage ids
row.names(ori) <- ori$CODE_IRIS

# Connexion to osrm local server
options(osrm.server = "http://localhost:5000/", osrm.profile = "bike")

# Origin-destination calculation
# All structures
df <- osrmTable(src = ori, dst = dest, measure = "duration")
df <- data.frame(df$duration)
colnames(df) <- as.character(dest$osm_id)
row.names(df) <- as.character(ori$CODE_IRIS)
write.csv(df, "data-conso/bike-duration.csv")

# Private structures
dest_priv <- dest[dest$type == "Speculative structure",] 
df2 <- osrmTable(src = ori, dst = dest_priv, measure = "duration")
df2 <- data.frame(df2$duration)
colnames(df2) <- as.character(dest_priv$osm_id)
row.names(df2) <- as.character(ori$CODE_IRIS)
write.csv(df2, "data-conso/bike-duration-priv.csv")

# FFME
dest_asso <-dest[dest$type == "Associative structure",] 
dest_ffme <- dest_asso[dest_asso$federation == "FFME",]
df3 <- osrmTable(src = ori, dst = dest_ffme, measure = "duration")
df3 <- data.frame(df3$duration)
colnames(df3) <- as.character(dest_ffme$osm_id)
row.names(df3) <- as.character(ori$CODE_IRIS)
write.csv(df3, "data-conso/bike-duration-ffme.csv")

# FSGT
dest_fsgt <- dest_asso[poi_asso$federation == "FSGT",]
df4 <- osrmTable(src = ori, dst = dest_fsgt, measure = "duration")
df4 <- data.frame(df4$duration)
colnames(df4) <- as.character(poi_fsgt$osm_id)
row.names(df4) <- as.character(ori$CODE_IRIS)
write.csv(df4, "data-conso/bike-duration-fsgt.csv")
```

## Computing indicators at IRIS level

This heavy matrix is then manipulated to extract for each IRIS the following information :

-   Name of the nearest climbing structure by bike

-   Type of structure (associative or speculative)

-   Time to reach it (in minutes)

-   Number of artificial climbing areas at less than 15 minutes by bike (N)

This calculation is done for all climbing structures (ALL), private ones (PRIV), the FFME federation (FFME) and the FSGT one (FSGT). It is done with R base code.

```{r, eval = FALSE}
# Name of the nearest structure
osm_id <- colnames(df)[apply(df, 1, which.min)] # Name
osm_id <- data.frame(osm_id, stringsAsFactors = FALSE)
osm_id$iris <- row.names(df)
osm_id <- merge(osm_id, poi[,c("osm_id", "name", "type")], 
                by = "osm_id", all.x = TRUE)

# Time to the nearest climbing area
time <- apply(df, 1, min) # Time
time <- data.frame(time, stringsAsFactors = FALSE)
time$iris <- row.names(time)
osm_id <- merge(osm_id, time, by = "iris", all.x = TRUE)
osm_id$geometry <- NULL

# Number of climbing area at less than 15 minutes by bike
n15mn <- df
n15mn <- data.frame(df, stringsAsFactors = FALSE)
n15mn[n15mn < 15] <- 1
n15mn[n15mn > 15] <- 0
n15mn$N <- rowSums(n15mn)
n15mn$iris <- row.names(n15mn)
osm_id <- merge(osm_id, n15mn[,c("iris", "N")], by = "iris",
                all.x = TRUE)
osm_id <- osm_id[,c(1,3:6)]
colnames(osm_id) <- c("CODE_IRIS", "ALL_NAME", "TYPE_STRUCT", "ALL_TIME",
                      "N_15MN")
iris <- merge(iris, osm_id, by = "CODE_IRIS", all.x = TRUE)

# Prive climbing club (fees $$$)
# Name of the nearest structure
osm_id <- colnames(df2)[apply(df2, 1, which.min)] # Name
osm_id <- data.frame(osm_id, stringsAsFactors = FALSE)
osm_id$iris <- row.names(df2)
osm_id <- merge(osm_id, poi[,c("osm_id", "name", "type")], 
                by = "osm_id", all.x = TRUE)

# Time to the nearest climbing area
time <- apply(df2, 1, min) # Time
time <- data.frame(time, stringsAsFactors = FALSE)
time$iris <- row.names(time)
osm_id <- merge(osm_id, time, by = "iris", all.x = TRUE)
osm_id$geometry <- NULL

# Number of climbing area at less than 15 minutes by bike
n15mn <- df2
n15mn <- data.frame(df2, stringsAsFactors = FALSE)
n15mn[n15mn < 15] <- 1
n15mn[n15mn > 15] <- 0
n15mn$N <- rowSums(n15mn)
n15mn$iris <- row.names(n15mn)
osm_id <- merge(osm_id, n15mn[,c("iris", "N")], by = "iris",
                all.x = TRUE)
osm_id <- osm_id[,c(1,3,5:6)]
colnames(osm_id) <- c("CODE_IRIS", "PRIV_NAME", "PRIV_TIME",
                      "N_PRIV_15MN")
iris <- merge(iris, osm_id, by = "CODE_IRIS", all.x = TRUE)

# FFME associative structure
# Name of the nearest structure
osm_id <- colnames(df3)[apply(df3, 1, which.min)] # Name
osm_id <- data.frame(osm_id, stringsAsFactors = FALSE)
osm_id$iris <- row.names(df3)
osm_id <- merge(osm_id, poi[,c("osm_id", "name", "type")], 
                by = "osm_id", all.x = TRUE)

# Time to the nearest climbing area
time <- apply(df3, 1, min) # Time
time <- data.frame(time, stringsAsFactors = FALSE)
time$iris <- row.names(time)
osm_id <- merge(osm_id, time, by = "iris", all.x = TRUE)
osm_id$geometry <- NULL

# Number of climbing area at less than 15 minutes by bike
n15mn <- df3
n15mn <- data.frame(df3, stringsAsFactors = FALSE)
n15mn[n15mn < 15] <- 1
n15mn[n15mn > 15] <- 0
n15mn$N <- rowSums(n15mn)
n15mn$iris <- row.names(n15mn)
osm_id <- merge(osm_id, n15mn[,c("iris", "N")], by = "iris",
                all.x = TRUE)
osm_id <- osm_id[,c(1,3,5:6)]
colnames(osm_id) <- c("CODE_IRIS", "FFME_NAME", "FFME_TIME",
                      "N_FFME_15MN")
iris <- merge(iris, osm_id, by = "CODE_IRIS", all.x = TRUE)

# FSGT associative structure
# Name of the nearest structure
osm_id <- colnames(df4)[apply(df4, 1, which.min)] # Name
osm_id <- data.frame(osm_id, stringsAsFactors = FALSE)
osm_id$iris <- row.names(df4)
osm_id <- merge(osm_id, poi[,c("osm_id", "name", "type")], 
                by = "osm_id", all.x = TRUE)

# Time to the nearest climbing area
time <- apply(df4, 1, min) # Time
time <- data.frame(time, stringsAsFactors = FALSE)
time$iris <- row.names(time)
osm_id <- merge(osm_id, time, by = "iris", all.x = TRUE)
osm_id$geometry <- NULL

# Number of climbing area at less than 15 minutes by bike
n15mn <- df4
n15mn <- data.frame(df4, stringsAsFactors = FALSE)
n15mn[n15mn < 15] <- 1
n15mn[n15mn > 15] <- 0
n15mn$N <- rowSums(n15mn)
n15mn$iris <- row.names(n15mn)
osm_id <- merge(osm_id, n15mn[,c("iris", "N")], by = "iris",
                all.x = TRUE)
osm_id <- osm_id[,c(1,3,5:6)]
colnames(osm_id) <- c("CODE_IRIS", "FSGT_NAME", "FSGT_TIME",
                      "N_FSGT_15MN")
iris <- merge(iris, osm_id, by = "CODE_IRIS", all.x = TRUE)
```

### Resulting indicators

Resulting geojson includes the followings attributes :

-   CODE_IRIS : IRIS code
-   NOM_IRIS : IRIS Name
-   ALL_NAME : Name of the nearest artificial climbing area by bike (all structures)
-   TYPE_STRUCT : Type of the nearest artificial climbing area by bike (speculative or associative)
-   ALL_TIME : Time by bike to reach the nearest artificial climbing area.
-   N_15MN : Number of climbing areas accessible in 15 minutes by bike from the IRIS centroid (all structures)
-   PRIV_NAME : Name of the nearest artificial climbing area by bike (Private structure)
-   PRIV_TIME : Time by bike to reach the nearest artificial climbing area (Private structure).
-   N_PRIV_15MN : Number of climbing areas accessible in 15 minutes by bike from the IRIS centroid (private structures).
-   FFME_NAME : Name of the nearest artificial climbing area by bike (Associative structure, federation : FFME)
-   FFME_TIME : Time by bike to reach the nearest artificial climbing area (Associative structure, federation : FFME).
-   N_FFME_15MN : Number of climbing areas accessible in 15 minutes by bike from the IRIS centroid (Associative structure, federation : FFME).
-   FSGT_NAME : Name of the nearest artificial climbing area by bike (Associative structure, federation : FSGT)
-   FSGT_TIME : Time by bike to reach the nearest artificial climbing area (Associative structure, federation : FSGT).
-   N_FSGT_15MN : Number of climbing areas accessible in 15 minutes by bike from the IRIS centroid (Associative structure, federation : FSGT).

```{r, echo = FALSE, warning=FALSE}
iris.df <- st_set_geometry(iris, NULL)
iris.df <- iris.df[iris.df$TYP_IRIS == "H",]
iris.df <- iris.df[,c(1,5,8:20)]


font.size <- "8pt"
library(DT)
datatable(iris.df, rownames = FALSE, escape = FALSE, 
          class = "hoover",
          options = list(dom = 't',  pageLength = nrow(iris.df), scrollY = "600px",
                 initComplete = htmlwidgets::JS(
          "function(settings, json) {",
          paste0("$(this.api().table().container()).css({'font-size': '", font.size, "'});"),
          "}")
       )) 
```

## 

## Characterizing the POI neighbourhood

For each climbing areas, we are interested in defining the socio-economic characteristics of their neighbourhood.

The previous matrix is transposed (lines \<\> columns). For each climbing structure, we extract the IRIS located at less than 15 minutes by bike and to produce the following indicators :

-   Total population at less than 15 minutes by bike. This can be considered as an amount of "social demand".

-   Minimum, mean and maximum of median income of IRIS at less than 15 minutes by bike.

```{r, eval = FALSE}
t.df <- data.frame(t(df))
colnames(t.df) <- iris10k[iris10k$TYP_IRIS == "H",]$CODE_IRIS
t.df$osm_id <- dest$osm_id
t.df <- t.df[t.df$osm_id %in% poi$osm_id,]

poi_socio <- data.frame(matrix(nrow = 0, ncol = 5))
colnames(poi_socio) <- c("osm_id", "SUM_POP18", "MIN_REV19", "MOY_REV19", "MAX_REV19")

for (i in 1:nrow(t.df)){
  tmp1 <- t.df[, t.df[i, ] < 15]
  tmp2 <- data.frame(CODE_IRIS = colnames(tmp1))
  tmp2 <- merge(tmp2, iris10k[,c("CODE_IRIS", "P18_POP", "DISP_MED19")],
             all.x = TRUE)
  
  poi_socio[i,1] <- row.names(tmp1)[i]
  poi_socio[i,2] <- sum(tmp2$P18_POP, na.rm = TRUE)
  poi_socio[i,3] <- min(tmp2$DISP_MED19, na.rm = TRUE)
  poi_socio[i,4] <- mean(tmp2$DISP_MED19, na.rm = TRUE)
  poi_socio[i,5] <- max(tmp2$DISP_MED19, na.rm = TRUE)
  }

poi <- merge(poi, poi_socio, by = "osm_id", all.x = TRUE)
```

### Resulting indicators

Resulting poi.geojson includes the followings attributes. Some of them comes directly from the OpenStreetMap database :

-   osm_id : OpenStreetMap identifier (responding to the query sport=climbing in the bounding box of the study area).

-   name : name of the artificial climbing area

-   climbing_type: If the articial climbing area is a wall (need a rope to climb), dedicated to bouldering, or both.

-   climbing_length: Height of the wall (if adapted, for walls)

-   climbing_routes: Number of climbing routes (if adapted, for walls)

-   brand: Name of the enterprise managing the private artificial climbing area

As demonstrated above, we have added several attributes for the need of the analysis, not originally included in the OpenStreetMap database :

-   type: Speculative or associative structure (speculative meaning private)

-   federation; Organization managing the artificial climbing area (private, FFME or FSGT)

-   SUM_POP18: Population at less than 15 minutes by bike of the artificial climbing area (IRIS centroids).

-   MIN_REV19: Mininum of the median income for the IRIS located at less than 15 minutes by bike.

-   MOY_REV19: Mean of the Median income for the IRIS located at less than 15 minutes by bike.

-   MAX_REV19: Maximum of the Median income for the IRIS located at less than 15 minutes by bike.

```{r, echo = FALSE, warning=FALSE}
poi.df <- st_set_geometry(poi, NULL)

font.size <- "8pt"
library(DT)
datatable(poi.df, rownames = FALSE, escape = FALSE, 
          class = "hoover",
          options = list(dom = 't',  pageLength = nrow(iris.df), scrollY = "600px",
                 initComplete = htmlwidgets::JS(
          "function(settings, json) {",
          paste0("$(this.api().table().container()).css({'font-size': '", font.size, "'});"),
          "}")
       )) 
```

## Map generalization

Geometries are quite detailed. The library `rmapshaper` (Teucher, 2022) is used to simplify the layer. 9 % of the points constituting the polygons are kept. Then, the IRIS layer is aggregated in communes for the map layout.

```{r, eval = FALSE}
library(rmapshaper)
iris <- ms_simplify(iris, keep = 0.09)

# Communes aggregation (layout)
com <- aggregate(iris[,c("INSEE_COM", "NOM_COM")],
                 by = list(iris$INSEE_COM),
                 FUN = head, 1)
```

## Export results

Data preparation is over, we can go the data visualization section. Resulting geojson (poi, iris ad communes) are exported in geojson.

```{r, eval = FALSE}
st_write(com, "data-conso/com.geojson")
st_write(iris, "data-conso/iris.geojson")
st_write(poi, "data-conso/poi.geojson")
```
